import { NextResponse } from 'next/server';
import { Document, Paragraph, TextRun, Packer } from 'docx';
import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash", apiVersion: "v1" });

export const config = {
  api: {
    bodyParser: false,
  },
};

export async function POST(request) {
  try {
    const contentType = request.headers.get('content-type');
    if (!contentType?.includes('multipart/form-data')) {
      return NextResponse.json({ error: 'Content-Type must be multipart/form-data' }, { status: 400 });
    }

    const formData = await request.formData();
    const file = formData.get('file');

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    if (file.type !== 'application/pdf') {
      return NextResponse.json({ error: 'Only PDF files are allowed' }, { status: 400 });
    }

    const arrayBuffer = await file.arrayBuffer();
    const base64Data = Buffer.from(arrayBuffer).toString('base64');

    const prompt = {
      contents: [
        {
          parts: [
            {
              inlineData: {
                mimeType: 'application/pdf',
                data: base64Data,
              },
            },
            {
              text: 'Summarize this document in 200-300 words.',
            },
          ],
        },
      ],
    };

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const summary = response.text();

    const doc = new Document({
      sections: [
        {
          children: [
            new Paragraph({
              children: [new TextRun({ text: "Document Summary", bold: true, size: 28 })],
            }),
            new Paragraph({
              children: [new TextRun({ text: "Generated by Gemini AI", italics: true })],
            }),
            new Paragraph({ children: [new TextRun("")] }),
            new Paragraph({
              children: [new TextRun(summary)],
            }),
          ],
        },
      ],
    });

    const docBuffer = await Packer.toBuffer(doc);

    return new NextResponse(docBuffer, {
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'Content-Disposition': 'attachment; filename="summary.docx"',
      },
    });

  } catch (error) {
    console.error('Processing error:', error);
    return NextResponse.json(
      {
        error: 'Processing failed',
        details: error.message,
        ...(process.env.NODE_ENV === 'development' && { stack: error.stack }),
      },
      { status: 500 }
    );
  }
}
